name: "Build and Deploy Flutter Web"
description: "Build Flutter web application and deploy to Firebase Hosting"

inputs:
  # Build inputs
  target_file:
    description: "Target Dart file to build (e.g., lib/main.dart)"
    required: true
  build_mode:
    description: "Build mode (release, debug, profile)"
    required: false
    default: "release"
  build_args:
    description: "Additional arguments for flutter build web"
    required: false
    default: ""
  output_dir:
    description: "Output directory name (e.g., web_app, web_restaurant). If not set, uses default build/web"
    required: false
    default: ""
  copy_to_output:
    description: "Whether to copy build/web to a custom output directory"
    required: false
    default: "false"

  # Widgetbook-specific inputs
  is_widgetbook:
    description: "Whether this is a Widgetbook build (runs build_runner first)"
    required: false
    default: "false"
  widgetbook_dir:
    description: "Path to widgetbook directory (if is_widgetbook is true)"
    required: false
    default: "widgetbook"
  build_runner_args:
    description: "Additional arguments for build_runner"
    required: false
    default: "--delete-conflicting-outputs"

  # Deployment inputs
  deploy:
    description: "Whether to deploy to Firebase Hosting"
    required: false
    default: "true"
  deploy_trigger_paths:
    description: "Newline-separated list of paths/patterns that should trigger deployment. If provided, deployment only occurs if files matching these paths have changed. If empty, deployment happens based on 'deploy' input only."
    required: false
    default: ""
  firebase_project_id:
    description: "Firebase project ID"
    required: true
  firebase_hosting_target:
    description: "Firebase hosting target (e.g., app, restaurant, admin, widgetbook)"
    required: false
    default: ""
  firebase_deploy_only:
    description: "Firebase deploy --only flag (e.g., 'hosting:app,functions,firestore,storage' or 'hosting:restaurant')"
    required: false
    default: ""
  firebase_deploy_args:
    description: "Additional arguments for firebase deploy (e.g., --non-interactive)"
    required: false
    default: ""
  service_account_path:
    description: "Path to Firebase service account JSON file"
    required: false
    default: "firebase_service_account.json"

runs:
  using: "composite"
  steps:
    - name: Check for skip deployment labels
      shell: bash
      id: check-skip-labels
      env:
        GITHUB_TOKEN: ${{ github.token }}
        PR_LABELS_JSON: ${{ toJSON(github.event.pull_request.labels) }}
      run: |
        echo "\n\n\nCHECK FOR SKIP DEPLOYMENT LABELS\n\n\n"
        set -e

        HOSTING_TARGET="${{ inputs.firebase_hosting_target }}"
        OUTPUT_DIR="${{ inputs.output_dir }}"
        EVENT_NAME="${{ github.event_name }}"
        SKIP_DEPLOY=false
        SKIP_REASON=""

        echo "üîç Checking for skip deployment labels..."
        echo "üìã Event: $EVENT_NAME"
        echo "üìã Hosting target: ${HOSTING_TARGET:-'(none)'}"
        echo "üìã Output directory: ${OUTPUT_DIR:-'(none)'}"
        echo ""

        # Function to normalize label name (lowercase, handle variations)
        normalize_label() {
          echo "$1" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9:]//g'
        }

        # Function to check if a label should skip deployment
        should_skip() {
          local label="$1"
          local normalized_label=$(normalize_label "$label")
          
          # Check for generic "no-deploy" label (case-insensitive)
          if [ "$normalized_label" = "nodeploy" ] || [ "$normalized_label" = "no-deploy" ]; then
            return 0
          fi
          
          # Check for generic "no-deploy-web" label (case-insensitive)
          if [ "$normalized_label" = "nodeployweb" ] || [ "$normalized_label" = "no-deploy-web" ]; then
            return 0
          fi
          
          # Check for hosting target-specific label (e.g., "no-deploy:app", "no deploy: app")
          if [ -n "$HOSTING_TARGET" ]; then
            local normalized_target=$(normalize_label "$HOSTING_TARGET")
            if echo "$normalized_label" | grep -qE "^nodeploy:${normalized_target}$|^no-deploy:${normalized_target}$"; then
              return 0
            fi
          fi
          
          # Check for web hosting target-specific label (e.g., "no-deploy-web:app", "no deploy-web: app")
          if [ -n "$HOSTING_TARGET" ]; then
            local normalized_target=$(normalize_label "$HOSTING_TARGET")
            if echo "$normalized_label" | grep -qE "^nodeployweb:${normalized_target}$|^no-deploy-web:${normalized_target}$"; then
              return 0
            fi
          fi
          
          # Check for output directory-specific label (e.g., "no-deploy:web_app", "no deploy: web_app")
          # Only if hosting target is not set
          if [ -z "$HOSTING_TARGET" ] && [ -n "$OUTPUT_DIR" ]; then
            local normalized_output=$(normalize_label "$OUTPUT_DIR")
            if echo "$normalized_label" | grep -qE "^nodeploy:${normalized_output}$|^no-deploy:${normalized_output}$"; then
              return 0
            fi
          fi
          
          return 1
        }

        # Get labels based on event type
        if [ "$EVENT_NAME" = "pull_request" ]; then
          # For PR events, check labels directly from event
          echo "üìã Checking PR labels..."
          
          # Extract label names from JSON (set as environment variable)
          if [ -n "$PR_LABELS_JSON" ] && [ "$PR_LABELS_JSON" != "null" ] && [ "$PR_LABELS_JSON" != "[]" ]; then
            # Try using jq if available
            if command -v jq >/dev/null 2>&1; then
              PR_LABELS=$(echo "$PR_LABELS_JSON" | jq -r '.[].name' 2>/dev/null | tr '\n' ' ' || echo "")
            else
              # Fallback: extract using sed/grep
              PR_LABELS=$(echo "$PR_LABELS_JSON" | grep -oE '"name"\s*:\s*"[^"]+"' | sed 's/"name"\s*:\s*"//g' | sed 's/"//g' | tr '\n' ' ' || echo "")
            fi
            
            # Trim whitespace
            PR_LABELS=$(echo "$PR_LABELS" | xargs)
            
            if [ -z "$PR_LABELS" ]; then
              echo "‚ÑπÔ∏è  No labels found on PR"
            else
              echo "üìã Found labels: $PR_LABELS"
              for label in $PR_LABELS; do
                if should_skip "$label"; then
                  SKIP_DEPLOY=true
                  SKIP_REASON="PR has skip label: $label"
                  echo "‚è≠Ô∏è  Found skip label: $label"
                  break
                fi
              done
            fi
          else
            echo "‚ÑπÔ∏è  No labels found on PR"
          fi
        else
          # For push events (e.g., after PR merge), try to get PR labels from commit message
          echo "üìã Checking merged PR labels from commit message..."
          
          # Extract PR number from commit message (GitHub merge commits typically include "Merge pull request #123")
          PR_NUMBER=$(git log -1 --pretty=%B | grep -oE 'Merge pull request #([0-9]+)|#([0-9]+)' | grep -oE '[0-9]+' | head -n 1 || echo "")
          
          if [ -n "$PR_NUMBER" ]; then
            echo "üìã Found PR number in commit: #$PR_NUMBER"
            
            # Use GitHub API to get PR labels
            API_URL="https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER"
            echo "üîç Fetching PR info from: $API_URL"
            
            # Fetch PR data (labels are in the response)
            PR_DATA=$(curl -s -H "Authorization: token $GITHUB_TOKEN" -H "Accept: application/vnd.github.v3+json" "$API_URL" || echo "")
            
            if [ -n "$PR_DATA" ] && echo "$PR_DATA" | grep -q '"labels"'; then
              # Extract label names from JSON response
              # Try using jq if available, otherwise use sed/awk
              if command -v jq >/dev/null 2>&1; then
                LABELS=$(echo "$PR_DATA" | jq -r '.labels[].name' 2>/dev/null | tr '\n' ' ' || echo "")
              else
                # Fallback: extract labels using sed (handles JSON arrays)
                LABELS=$(echo "$PR_DATA" | sed -n '/"labels":\s*\[/,/\]/p' | grep -oE '"name"\s*:\s*"[^"]+"' | sed 's/"name"\s*:\s*"//g' | sed 's/"//g' | tr '\n' ' ' || echo "")
              fi
              
              # Trim whitespace
              LABELS=$(echo "$LABELS" | xargs)
              
              if [ -n "$LABELS" ]; then
                echo "üìã Found labels on merged PR: $LABELS"
                for label in $LABELS; do
                  if should_skip "$label"; then
                    SKIP_DEPLOY=true
                    SKIP_REASON="Merged PR #$PR_NUMBER has skip label: $label"
                    echo "‚è≠Ô∏è  Found skip label: $label"
                    break
                  fi
                done
              else
                echo "‚ÑπÔ∏è  No labels found on merged PR"
              fi
            else
              echo "‚ö†Ô∏è  Could not fetch PR data or PR not found (might be a direct push)"
            fi
          else
            echo "‚ÑπÔ∏è  No PR number found in commit message (might be a direct push)"
          fi
        fi

        if [ "$SKIP_DEPLOY" = "true" ]; then
          echo ""
          echo "‚è≠Ô∏è  Build and deployment will be skipped: $SKIP_REASON"
          echo "skip_deploy=true" >> $GITHUB_OUTPUT
        else
          echo ""
          echo "‚úÖ No skip labels found, build and deployment will proceed"
          echo "skip_deploy=false" >> $GITHUB_OUTPUT
        fi

    - name: Build Flutter Web
      shell: bash
      if: steps.check-skip-labels.outputs.skip_deploy != 'true'
      run: |
        echo "\n\n\nBUILD FLUTTER WEB\n\n\n"
        TARGET_FILE="${{ inputs.target_file }}"
        BUILD_MODE="${{ inputs.build_mode }}"
        BUILD_ARGS="${{ inputs.build_args }}"
        OUTPUT_DIR="${{ inputs.output_dir }}"
        COPY_TO_OUTPUT="${{ inputs.copy_to_output }}"
        IS_WIDGETBOOK="${{ inputs.is_widgetbook }}"
        WIDGETBOOK_DIR="${{ inputs.widgetbook_dir }}"

        if [ "$IS_WIDGETBOOK" = "true" ]; then
          echo "üîç Building Widgetbook..."
          
          # Check if widgetbook directory exists
          if [ ! -d "$WIDGETBOOK_DIR" ]; then
            echo "‚ùå Widgetbook directory not found: $WIDGETBOOK_DIR"
            exit 1
          fi
          
          cd "$WIDGETBOOK_DIR"
          
          # Run build_runner
          echo "üì¶ Running build_runner..."
          dart run build_runner build ${{ inputs.build_runner_args }}
          
          # Build web
          echo "üåê Building web..."
          flutter build web $BUILD_ARGS
          
          echo "‚úÖ Build Widgetbook completed and is in $WIDGETBOOK_DIR/build/web"
          
          cd ..
        else
          echo "üîç Building Flutter Web..."
          echo "üìã Target: $TARGET_FILE"
          echo "üìã Mode: $BUILD_MODE"
          
          # Build Flutter web
          flutter build web --$BUILD_MODE -t "$TARGET_FILE" $BUILD_ARGS
          
          # Copy to custom output directory if requested
          if [ "$COPY_TO_OUTPUT" = "true" ] && [ -n "$OUTPUT_DIR" ]; then
            echo "üìÅ Copying build/web to build/$OUTPUT_DIR..."
            mkdir -p "build/$OUTPUT_DIR"
            cp -r build/web/* "build/$OUTPUT_DIR"
            echo "‚úÖ Build completed and copied to build/$OUTPUT_DIR"
          else
            echo "‚úÖ Build Flutter Web completed in build/web"
          fi
        fi

    - name: Check if deployment should be triggered
      shell: bash
      id: check-deploy
      if: |
        inputs.deploy == 'true' && 
        inputs.deploy_trigger_paths != '' && 
        steps.check-skip-labels.outputs.skip_deploy != 'true'
      run: |
        echo "\n\n\nCHECK IF DEPLOYMENT SHOULD BE TRIGGERED\n\n\n"
        set -e

        DEPLOY_TRIGGER_PATHS="${{ inputs.deploy_trigger_paths }}"

        echo "üîç Checking if files in trigger paths have changed..."
        echo "üìã Watching paths:"
        echo "$DEPLOY_TRIGGER_PATHS" | sed 's/^/  - /'
        echo ""

        # Determine the base commit to compare against
        if [ "${{ github.event_name }}" == "pull_request" ]; then
          BASE_BRANCH="${{ github.event.pull_request.base.ref }}"
          BASE_REF="${{ github.event.pull_request.base.sha }}"
          echo "üìã Comparing PR branch against base: $BASE_BRANCH"
          git fetch origin "$BASE_BRANCH:$BASE_BRANCH" 2>/dev/null || echo "Could not fetch base branch"
        else
          # For pushes, compare against the previous commit
          BASE_REF="HEAD~1"
          echo "üìã Comparing against previous commit (HEAD~1)"
        fi

        # Check for changes in each trigger path
        HAS_CHANGES=false
        CHANGED_FILES=""

        # Process each path (split by newline)
        while IFS= read -r path; do
          # Skip empty lines
          [ -z "$path" ] && continue

          # Trim whitespace
          path=$(echo "$path" | xargs)

          # Check if path exists (as file or directory)
          if [ ! -e "$path" ] && [ ! -d "$path" ]; then
            echo "‚ö†Ô∏è  Path does not exist: $path (will still check git diff)"
          fi

          # Check for changes using git diff (with fallbacks)
          CHANGED=""
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            # Try multiple fallback strategies for PRs
            CHANGED=$(git diff --name-only "$BASE_REF" HEAD -- "$path" 2>/dev/null || \
                     git diff --name-only "$BASE_BRANCH" HEAD -- "$path" 2>/dev/null || \
                     git diff --name-only HEAD~1 HEAD -- "$path" 2>/dev/null || \
                     echo "")
          else
            # For pushes, compare against previous commit
            CHANGED=$(git diff --name-only "$BASE_REF" HEAD -- "$path" 2>/dev/null || echo "")
          fi

          if [ -n "$CHANGED" ]; then
            echo "‚úÖ Found changes in: $path"
            echo "$CHANGED" | sed 's/^/    - /'
            HAS_CHANGES=true
            if [ -n "$CHANGED_FILES" ]; then
              CHANGED_FILES="$CHANGED_FILES"$'\n'"$CHANGED"
            else
              CHANGED_FILES="$CHANGED"
            fi
          else
            echo "‚è≠Ô∏è  No changes in: $path"
          fi
        done <<< "$DEPLOY_TRIGGER_PATHS"

        if [ "$HAS_CHANGES" = "true" ]; then
          echo ""
          echo "‚úÖ Deployment will be triggered (files changed in watched paths)"
          echo "should_deploy=true" >> $GITHUB_OUTPUT
        else
          echo ""
          echo "‚è≠Ô∏è  Deployment will be skipped (no changes in watched paths)"
          echo "should_deploy=false" >> $GITHUB_OUTPUT
        fi

    - name: Deploy to Firebase Hosting
      shell: bash
      if: |
        inputs.deploy == 'true' && 
        steps.check-skip-labels.outputs.skip_deploy != 'true' &&
        (inputs.deploy_trigger_paths == '' || steps.check-deploy.outputs.should_deploy == 'true')
      env:
        GOOGLE_APPLICATION_CREDENTIALS: ${{ github.workspace }}/${{ inputs.service_account_path }}
      run: |
        echo "\n\n\nDEPLOY TO FIREBASE HOSTING\n\n\n"
        FIREBASE_PROJECT_ID="${{ inputs.firebase_project_id }}"
        FIREBASE_HOSTING_TARGET="${{ inputs.firebase_hosting_target }}"
        FIREBASE_DEPLOY_ONLY="${{ inputs.firebase_deploy_only }}"
        FIREBASE_DEPLOY_ARGS="${{ inputs.firebase_deploy_args }}"
        IS_WIDGETBOOK="${{ inputs.is_widgetbook }}"
        WIDGETBOOK_DIR="${{ inputs.widgetbook_dir }}"

        echo "üîç Using service account authentication"
        echo "üìã Service account file: $GOOGLE_APPLICATION_CREDENTIALS"

        # Determine deploy command
        if [ -n "$FIREBASE_DEPLOY_ONLY" ]; then
          # Use explicit --only flag
          DEPLOY_CMD="firebase deploy --only $FIREBASE_DEPLOY_ONLY --project $FIREBASE_PROJECT_ID"
        elif [ -n "$FIREBASE_HOSTING_TARGET" ]; then
          # Use hosting target
          DEPLOY_CMD="firebase deploy --only hosting:$FIREBASE_HOSTING_TARGET --project $FIREBASE_PROJECT_ID"
        else
          # Default to hosting only
          DEPLOY_CMD="firebase deploy --only hosting --project $FIREBASE_PROJECT_ID"
        fi

        # Add additional arguments if provided
        if [ -n "$FIREBASE_DEPLOY_ARGS" ]; then
          DEPLOY_CMD="$DEPLOY_CMD $FIREBASE_DEPLOY_ARGS"
        fi

        echo "üöÄ Deploying to Firebase..."
        echo "üìã Command: $DEPLOY_CMD"
        $DEPLOY_CMD

        echo "‚úÖ Deployment completed"
